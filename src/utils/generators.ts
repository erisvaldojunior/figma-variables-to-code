import { rgbaObjectToDartHexaString } from './converters';
import { toCamelCase, toPascalCase, toSingleQuotes } from './string';

type VariableValueType = {
	valueContent: string;
	valueType: 'alias' | 'color' | 'primitive' | undefined;
};

/**
 * Generates the complete Dart code from Figma Variables.
 * @returns The generated Dart code (entire file).
 */
export function generateDartCode(): string {
	const collections = figma.variables.getLocalVariableCollections();
	const variables = figma.variables.getLocalVariables();
	// Import dart:ui, needed for Dart Color class
	let dartFile = `// WARNING: This file is auto-generated by the figma-variables-to-code plugin.
// DO NOT manually modify this file. Any manual changes will be overwritten
// during the next generation process.
`;
	// eslint-disable-next-line quotes
	dartFile += "import 'dart:ui';\n\n";
	// Generate a root abstract class for Figma Variables
	dartFile += 'abstract final class Variables {\n';
	collections.forEach((collection) => {
		dartFile += `  static const ${toCamelCase(collection.name)} = ${toPascalCase(collection.name)}();\n`;
	});
	dartFile += '}\n';
	// Generate a class for each collection
	collections.forEach((collection) => {
		dartFile += '\n';
		const collectionVariables = variables.filter(
			(variable) => variable.variableCollectionId === collection.id
		);
		dartFile += generateDartCodeForCollection(
			collection,
			collectionVariables,
			variables
		);
	});
	return dartFile;
}

/*
 ** Converts a value to a Dart string representation
 */
function generateDartValueString(
	variable: Variable,
	figmaVariables: Variable[]
): VariableValueType {
	const variableId = variable.id;
	const variableObject = <Variable>(
		figmaVariables.find((obj) => obj.id === variableId)
	);
	const variableValueObject = variableObject.valuesByMode;
	if (variableValueObject) {
		const variableValueKey = Object.keys(variableValueObject)[0];
		if (variableValueKey) {
			const value: VariableValue = variableValueObject[variableValueKey];
			if (value) {
				if (isVariableAlias(value)) {
					const variableAlias = value as VariableAlias;
					const relatedVariableObject = figmaVariables.find(
						(obj) => obj.id === variableAlias.id
					);
					if (relatedVariableObject) {
						return {
							valueContent: `Variables.${generateDartKeyString(relatedVariableObject)}`,
							valueType: 'alias',
						};
					}
				} else if (variableObject.resolvedType === 'COLOR') {
					return {
						valueContent: rgbaObjectToDartHexaString(value as RGBA),
						valueType: 'color',
					};
				} else {
					// Assuming 'value' is a primitive (number, string, etc)
					return {
						valueContent: JSON.stringify(variableValueObject[variableValueKey]),
						valueType: 'primitive',
					};
				}
			}
		}
	}
	return { valueContent: '0', valueType: 'primitive' }; // generated code will be 0
}

/**
 * Generates a Dart key string for a variable, including the full class path.
 * @param variable - The variable to generate the key for.
 * @returns The generated Dart key string.
 */
function generateDartKeyString(variable: Variable): string {
	const parts = variable.name.split('/');
	let transformedVariableName = '';
	for (let i = 0; i < parts.length; i++) {
		const part = parts[i].trim();
		const capitalizedPart =
			(i > 0 ? part.charAt(0).toUpperCase() : part.charAt(0)) + part.slice(1);
		transformedVariableName += capitalizedPart;
	}
	// Generate the full path based on the collection and groups
	const collection = figma.variables
		.getLocalVariableCollections()
		.find((collection) => collection.id === variable.variableCollectionId);
	if (!collection) return transformedVariableName;
	const collectionName = toCamelCase(collection.name);
	const groupPath = parts.slice(0, -1);
	let transformedGroupPath = '';
	for (let i = 0; i < groupPath.length; i++) {
		const part = parts[i].trim();
		const capitalizedPart =
			(i > 0 ? part.charAt(0).toUpperCase() : part.charAt(0)) + part.slice(1);
		transformedGroupPath += capitalizedPart;
	}
	const fullPath =
		groupPath.length > 0
			? `${collectionName}.${transformedGroupPath}`
			: collectionName;
	const tokenName = toCamelCase(parts[parts.length - 1]);
	// Prefix with 'n' if starts with a number
	return /^\d/.test(tokenName)
		? `${fullPath}.n${tokenName}`
		: `${fullPath}.${tokenName}`;
}

/**
 * Generates Dart code for a variable.
 * @param variable - The variable to generate code for.
 * @param figmaVariables - The list of all Figma variables.
 * @returns The generated Dart code as a string.
 */
function generateDartCodeForVariable(
	variable: Variable,
	figmaVariables: Variable[]
): string {
	const variableObject = <Variable>(
		figmaVariables.find((obj) => obj.id === variable.id)
	);
	const dartKey = generateDartKeyString(variable);
	const { valueContent, valueType } = generateDartValueString(
		variable,
		figmaVariables
	);
	const resolvedType = variableObject.resolvedType;
	let doubleKeyPlusSpace = '';
	let value = valueContent;
	if (resolvedType === 'STRING') {
		value = toSingleQuotes(valueContent);
	} else if (resolvedType === 'FLOAT') {
		doubleKeyPlusSpace = 'double ';
	}
	let dartCode = '\n';
	dartCode += `  static ${valueType === 'primitive' ? 'const' : 'final'} ${doubleKeyPlusSpace}_${dartKey} = ${value};\n`;
	dartCode += `  ${getDartType(resolvedType)} get ${dartKey} => _${dartKey};\n`;
	return dartCode;
}

/**
 * Generates Dart code for a collection of variables.
 * @param collection - The collection of variables.
 * @param variables - The list of variables in the collection.
 * @param figmaVariables - The list of all Figma variables.
 * @returns The generated Dart code for the collection.
 */
function generateDartCodeForCollection(
	collection: VariableCollection,
	variables: Variable[],
	figmaVariables: Variable[]
): string {
	// Converts collection name to PascalCase
	const collectionName = toPascalCase(collection.name);
	// Start creating the Dart class with PascalCase class name
	let dartCode = `final class ${collectionName} {\n`;
	// Create class constructor
	dartCode += `  const ${collectionName}();\n`;
	// Group variables by their group name
	const groupedVariables = variables.reduce(
		(acc: Record<string, Variable[]>, variable: Variable) => {
			const parts = variable.name.split('/');
			const groupName =
				parts.length > 1 ? toCamelCase(parts.slice(0, -1).join('_')) : '';
			const variableName = toCamelCase(parts[parts.length - 1]);
			if (!groupName) {
				// Variables in the root of the collection
				if (!acc['__root__']) {
					acc['__root__'] = [];
				}
				acc['__root__'].push({ ...variable, name: variableName });
			} else {
				if (!acc[groupName]) {
					acc[groupName] = [];
				}
				acc[groupName].push({ ...variable, name: variableName });
			}
			return acc;
		},
		{}
	);
	// Iterate over the grouped variables and generate Dart code
	Object.keys(groupedVariables).forEach((groupName) => {
		if (groupName === '__root__') {
			// Generate Dart code for variables in the root of the collection
			groupedVariables[groupName].forEach((variable) => {
				dartCode += generateDartCodeForVariable(variable, figmaVariables);
			});
		} else {
			const groupNameCamelCase = toCamelCase(groupName);
			const groupNamePascalCase = toPascalCase(groupName);
			dartCode += '\n';
			dartCode += `  static const _${groupNameCamelCase} = ${groupNamePascalCase}();\n`;
			dartCode += `  ${groupNamePascalCase} get ${groupNameCamelCase} => _${groupNameCamelCase};\n`;
		}
	});
	// Close the Dart class
	dartCode += '}\n';
	// Generate separate classes for each group outside the parent class
	Object.keys(groupedVariables).forEach((groupName) => {
		if (groupName !== '__root__') {
			dartCode += '\n';
			dartCode += `final class ${toPascalCase(groupName)} {\n`;
			dartCode += `  const ${toPascalCase(groupName)}();\n`;
			groupedVariables[groupName].forEach((variable) => {
				dartCode += generateDartCodeForVariable(variable, figmaVariables);
			});
			dartCode += '}\n';
		}
	});
	return dartCode;
}

/**
 * Gets the Dart type for a given variable type.
 * @param variableType - The variable type to convert.
 * @returns The corresponding Dart type as a string.
 */
function getDartType(variableType: VariableResolvedDataType): string {
	if (variableType === 'BOOLEAN') return 'bool';
	if (variableType === 'COLOR') return 'Color';
	if (variableType === 'FLOAT') return 'double';
	if (variableType === 'STRING') return 'String';
	throw new Error('Unknown variable type');
}

function isVariableAlias(value: any): value is VariableAlias {
	return (
		value && value.type === 'VARIABLE_ALIAS' && typeof value.id === 'string'
	);
}
